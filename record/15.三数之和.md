# 15.三数之和

```ts
/*
 * @lc app=leetcode.cn id=15 lang=typescript
 *
 * [15] 三数之和
 */

// @lc code=start
function threeSum(nums: number[]): number[][] {}
// @lc code=end
```

## 解法 1: 暴力解法 三层遍历

时间复杂度: `O(n^3)`
空间复杂度: `O(1)`

```ts
function threeSum(nums: number[]): number[][] {
  let cache: { [key: string]: number[] } = {}
  for (let i = 0; i < nums.length - 2; i++) {
    for (let j = i + 1; j < nums.length - 1; j++) {
      for (let k = j + 1; k < nums.length; k++) {
        if (nums[i] + nums[j] + nums[k] === 0) {
          let arr = [nums[i], nums[j], nums[k]]
          let key = arr.sort((a, b) => a - b).join('')
          cache[key] = arr
        }
      }
    }
  }

  return Object.values(cache)
}
```

## 解法 2: 优化为两层遍历

时间复杂度: `O(n^2)`
空间复杂度: `O(n)`

```ts
function threeSum(nums: number[]): number[][] {
  let arrCache: { [key: string]: number[] } = {}
  let cache = new Set<number>()
  for (let i = 0; i < nums.length - 2; i++) {
    cache = new Set()
    let num = nums[i]
    for (let j = i + 1; j < nums.length; j++) {
      if (cache.has(-num - nums[j])) {
        let arr = [num, -num - nums[j], nums[j]]
        arrCache[[...arr].sort((a, b) => a - b).join('')] = arr
      }
      cache.add(nums[j])
    }
  }

  return Object.values(arrCache)
}
```

## 解法 3: 排序 + 双指针

时间复杂度: `O(n^2)`
空间复杂度: `O(n)`

```ts
function threeSum(nums: number[]): number[][] {
  let newNums = [...nums].sort((a, b) => a - b)
  let length = newNums.length
  let res: number[][] = []
  for (let i = 0; i < length; i++) {
    const first = newNums[i]
    if (first > 0) {
      // 当第一个值大于 0 时,后面三数相加必大于,可以直接排除后面的所有情况
      break
    }
    if (i > 0 && newNums[i] === newNums[i - 1]) {
      // 当和前面的值相等时,也就是重复情况,跳过
      continue
    }

    let left = i + 1,
      right = length - 1
    while (left < right) {
      const second = newNums[left],
        third = newNums[right]
      if (third < 0) {
        // 当最后一个值小于 0 时,那三数相加必小于 0,直接跳到下一个 i
        break
      }
      const sum = first + second + third

      if (sum === 0) {
        res.push([first, second, third])
        left++
        right--
        while (left < right && newNums[left] === newNums[left - 1]) {
          // 排除左指针的重复情况
          left++
        }
        while (left < right && newNums[right] === newNums[right + 1]) {
          // 排除右指针的重复情况
          right--
        }
      } else if (sum < 0) {
        left++
      } else {
        right--
      }
    }
  }
  return res
}
```

## Case

```text
[-1,0,1,2,-1,-4]\n
[0,0,0]\n
[-1,0,1,2,-1,-4,-2,-3,3,0,4]\n
[-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]
```
