# 37.解数独

```ts
/*
 * @lc app=leetcode.cn id=37 lang=typescript
 *
 * [37] 解数独
 */

// @lc code=start
/**
 Do not return anything, modify board in-place instead.
 */
function solveSudoku(board: string[][]): void {}
// @lc code=end
```

## 解法 1: 回溯+剪枝

- 回溯: 每个格子可以选择放 1~9 的数字
- 剪枝: 判断在同一行,列,块中是否已经有相同数字

```ts
function solveSudoku(board: string[][]): void {
  const cache = new Set()

  const createStr = (num: number | string, i = 0, j = 0) => {
    const row = `${num} in row ${i}`
    const col = `${num} in col ${j}`
    const block = `${num} in block ${Math.floor(i / 3) * 3 + Math.floor(j / 3)}`
    return [row, col, block]
  }

  for (let i = 0; i < 9; i++) {
    for (let j = 0; j < 9; j++) {
      if (board[i][j] === '.') continue
      createStr(board[i][j], i, j).forEach(v => cache.add(v))
    }
  }

  const dfs = (i: number, j: number): boolean => {
    if (i === 8 && j === 9) return true

    if (j === 9) {
      // 当前行已经遍历完,进到下一行
      return dfs(i + 1, 0)
    } else if (board[i][j] === '.') {
      for (let num = 1; num <= 9; num++) {
        const strs = createStr(num, i, j)
        // 剪枝
        if (strs.some(v => cache.has(v))) continue

        board[i][j] = num + ''
        strs.forEach(v => cache.add(v))
        if (dfs(i, j + 1)) return true

        // 回溯
        strs.forEach(v => cache.delete(v))
        board[i][j] = '.'
      }
    } else {
      return dfs(i, j + 1)
    }
    return false
  }
  dfs(0, 0)
}
```

## Case

```ts
test.each([
  {
    input: {
      board: [
        ['5', '3', '.', '.', '7', '.', '.', '.', '.'],
        ['6', '.', '.', '1', '9', '5', '.', '.', '.'],
        ['.', '9', '8', '.', '.', '.', '.', '6', '.'],
        ['8', '.', '.', '.', '6', '.', '.', '.', '3'],
        ['4', '.', '.', '8', '.', '3', '.', '.', '1'],
        ['7', '.', '.', '.', '2', '.', '.', '.', '6'],
        ['.', '6', '.', '.', '.', '.', '2', '8', '.'],
        ['.', '.', '.', '4', '1', '9', '.', '.', '5'],
        ['.', '.', '.', '.', '8', '.', '.', '7', '9'],
      ],
    },
    output: [
      ['5', '3', '4', '6', '7', '8', '9', '1', '2'],
      ['6', '7', '2', '1', '9', '5', '3', '4', '8'],
      ['1', '9', '8', '3', '4', '2', '5', '6', '7'],
      ['8', '5', '9', '7', '6', '1', '4', '2', '3'],
      ['4', '2', '6', '8', '5', '3', '7', '9', '1'],
      ['7', '1', '3', '9', '2', '4', '8', '5', '6'],
      ['9', '6', '1', '5', '3', '7', '2', '8', '4'],
      ['2', '8', '7', '4', '1', '9', '6', '3', '5'],
      ['3', '4', '5', '2', '8', '6', '1', '7', '9'],
    ],
  },
  {
    input: {
      board: [
        ['.', '.', '9', '7', '4', '8', '.', '.', '.'],
        ['7', '.', '.', '.', '.', '.', '.', '.', '.'],
        ['.', '2', '.', '1', '.', '9', '.', '.', '.'],
        ['.', '.', '7', '.', '.', '.', '2', '4', '.'],
        ['.', '6', '4', '.', '1', '.', '5', '9', '.'],
        ['.', '9', '8', '.', '.', '.', '3', '.', '.'],
        ['.', '.', '.', '8', '.', '3', '.', '2', '.'],
        ['.', '.', '.', '.', '.', '.', '.', '.', '6'],
        ['.', '.', '.', '2', '7', '5', '9', '.', '.'],
      ],
    },
    output: [
      ['5', '1', '9', '7', '4', '8', '6', '3', '2'],
      ['7', '8', '3', '6', '5', '2', '4', '1', '9'],
      ['4', '2', '6', '1', '3', '9', '8', '7', '5'],
      ['3', '5', '7', '9', '8', '6', '2', '4', '1'],
      ['2', '6', '4', '3', '1', '7', '5', '9', '8'],
      ['1', '9', '8', '5', '2', '4', '3', '6', '7'],
      ['9', '7', '5', '8', '6', '3', '1', '2', '4'],
      ['8', '3', '2', '4', '9', '1', '7', '5', '6'],
      ['6', '4', '1', '2', '7', '5', '9', '8', '3'],
    ],
  },
])('input: board = $input.board', ({ input: { board }, output }) => {
  solveSudoku(board)
  expect(board).toEqual(output)
})
```
