# 123.买卖股票的最佳时机-iii

```ts
/*
 * @lc app=leetcode.cn id=123 lang=typescript
 *
 * [123] 买卖股票的最佳时机 III
 */

// @lc code=start
function maxProfit(prices: number[]): number {}
// @lc code=end
```

## 解法 1: 动态规划 - 三维 DP

- 推荐阅读
- [团灭 LeetCode 股票买卖问题](https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%9B%A2%E7%81%AD%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98.md)
- [Most consistent ways of dealing with the series of stock problems](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems)

1. 子问题: 如何求出第 i 天的最大利润?
   - 通过 i-1 天各种状态下的最大利润,可以获得第 i 天各种状态下的最大利润.
2. 定义状态:
   1. 天数: i
   2. 交易次数: k -> 0,1,2
   3. 是否持有股票: h -> 0: 未持有, 1: 持有
3. DP 方程:
   - `dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1]+price)`
   - `dp[i][k][1] = max(dp[i-1][k][1],dp[i-1][k-1][0]-price)`
4. 初始状态: 没有股票或者没有交易产生时,利润为 0;而当没有股票或者没有交易产生时,就不可能持有股票,用 -Infinity 来表示
   - 第 0 天
     - `dp[0]=[[0,-Infinity],[0,-Infinity],[0,-Infinity]]`
   - 第 i 天的第 0 次交易
     - `dp[i][0]=[0,-Infinity]`

|      | 交易 0 次     | 交易 1 次     | 交易 2 次     |
| ---- | ------------- | ------------- | ------------- |
| 0 天 | [0,-Infinity] | [0,-Infinity] | [0,-Infinity] |
| 1 天 | [0,-Infinity] | -             | -             |
| 2 天 | [0,-Infinity] | -             | -             |
| 3 天 | [0,-Infinity] | -             | -             |
| ...  | ...           | ...           | ...           |

> 代码中因为没有用到 0 次交易的持有状态,所以省去,加上也不影响结果

```ts
function maxProfit(prices: number[]): number {
  const dp = [
    [
      [0, -Infinity],
      [0, -Infinity],
      [0, -Infinity],
    ],
  ]

  for (let i = 1; i <= prices.length; i++) {
    const price = prices[i - 1]
    dp[i] = [[0, -Infinity]]
    for (let k = 1; k <= 2; k++) {
      dp[i][k] = []
      dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + price)
      dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - price)
    }
  }
  return dp[prices.length][2][0]
}
```

## 解法 2: 二维 DP

1. 子问题: 如何求出第 i 天的最大利润?
2. 状态:
   1. 天数: i
   2. 交易与持有状态(每次买入的时候增加交易次数):
      - `0` 交易 0 次,未交易未持有
      - `1` 交易 1 次,持有 -> 第 1 次买入,或保持现状
      - `2` 交易 1 次,未持有 -> 第 1 次卖出,或保持现状
      - `3` 交易 2 次,持有 -> 第 2 次买入,或保持现状
      - `4` 交易 2 次,未持有 -> 第 2 次卖出,或保持现状
3. DP 方程:
   - `dp[i][0] = 0`
   - `dp[i][1] = max(dp[i-1][1],-price)`
   - `dp[i][2] = max(dp[i-1][1]+price,dp[i-1][2])`
   - `dp[i][3] = max(dp[i-1][2]-price,dp[i-1][3])`
   - `dp[i][4] = max(dp[i-1][3]+price,dp[i-1][4])`
4. 初始状态:
   - 第 0 天
     - `dp[0] = [ -Infinity, 0, -Infinity, 0]`

|      | 状态 1    | 状态 2 | 状态 3    | 状态 4 |
| ---- | --------- | ------ | --------- | ------ |
| 0 天 | -Infinity | 0      | -Infinity | 0      |
| 1 天 | -         | -      | -         | -      |
| 2 天 | -         | -      | -         | -      |
| 3 天 | -         | -      | -         | -      |
| ...  | ...       | ...    | ...       | ...    |

```ts
function maxProfit(prices: number[]): number {
  const dp: number[][] = [[0, -Infinity, -Infinity, -Infinity, -Infinity]]

  for (let i = 1; i <= prices.length; i++) {
    const price = prices[i - 1]
    dp[i] = [0]
    dp[i][1] = Math.max(dp[i - 1][1], -price)
    dp[i][2] = Math.max(dp[i - 1][1] + price, dp[i - 1][2])
    dp[i][3] = Math.max(dp[i - 1][2] - price, dp[i - 1][3])
    dp[i][4] = Math.max(dp[i - 1][3] + price, dp[i - 1][4])
  }
  return Math.max(0, dp[prices.length][2], dp[prices.length][4])
}
```

## 解法 3: 二维 DP 优化

- [官方题解](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/)

```ts
function maxProfit(prices: number[]): number {
  const dp: number[][] = [[0, -Infinity, -Infinity, -Infinity, -Infinity]]

  for (let i = 1; i <= prices.length; i++) {
    const price = prices[i - 1]
    dp[i] = [0]
    dp[i][1] = Math.max(dp[i - 1][1], -price)
    dp[i][2] = Math.max(dp[i][1] + price, dp[i - 1][2])
    dp[i][3] = Math.max(dp[i][2] - price, dp[i - 1][3])
    dp[i][4] = Math.max(dp[i][3] + price, dp[i - 1][4])
  }
  return dp[prices.length][4]
}
```

其实状态 0 不影响其余状态,可以省去

```ts
function maxProfit(prices: number[]): number {
  const dp: number[][] = [[-Infinity, -Infinity, -Infinity, -Infinity]]

  for (let i = 1; i <= prices.length; i++) {
    const price = prices[i - 1]
    dp[i] = []
    dp[i][0] = Math.max(dp[i - 1][0], -price)
    dp[i][1] = Math.max(dp[i][0] + price, dp[i - 1][1])
    dp[i][2] = Math.max(dp[i][1] - price, dp[i - 1][2])
    dp[i][3] = Math.max(dp[i][2] + price, dp[i - 1][3])
  }
  return dp[prices.length][3]
}
```

## 解法 4: 一维 DP

因为每次只用到前一天的状态,所以可以重复利用一个一维数组

```ts
function maxProfit(prices: number[]): number {
  const dp: number[] = [0, -Infinity, -Infinity, -Infinity, -Infinity]

  for (let i = 1; i <= prices.length; i++) {
    const price = prices[i - 1]
    dp[1] = Math.max(dp[1], -price)
    dp[2] = Math.max(dp[1] + price, dp[2])
    dp[3] = Math.max(dp[2] - price, dp[3])
    dp[4] = Math.max(dp[3] + price, dp[4])
  }
  return dp[4]
}
```

## Case

```ts
test.each([
  { prices: [3, 3, 5, 0, 0, 3, 1, 4], result: 6 },
  { prices: [1, 2, 3, 4, 5], result: 4 },
  { prices: [7, 6, 4, 3, 1], result: 0 },
  { prices: [1], result: 0 },
])('prices = $prices', ({ prices, result }) => {
  expect(maxProfit(prices)).toBe(result)
})
```
