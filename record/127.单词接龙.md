# 127.单词接龙

```ts
/*
 * @lc app=leetcode.cn id=127 lang=typescript
 *
 * [127] 单词接龙
 */

// @lc code=start
function ladderLength(
  beginWord: string,
  endWord: string,
  wordList: string[],
): number {}
// @lc code=end
```

## 解法 1: BFS(广度优先搜索)

1. 将每个单词,使用 26 个字幕逐个字符替换得到新的单词
2. 然后检查新的单词是否为目标单词,如果是直接返回深度即是最短序列
3. 如果不是,在检查是否在字典中,如果在字典中,那有可能是一个中间单词,加入列表到下一层遍历
4. 如此循环,知道找不到新的中间单词,则返回 0

```ts
function ladderLength(
  beginWord: string,
  endWord: string,
  wordList: string[],
): number {
  const wordMap = new Set<string>(wordList)
  if (!wordMap.has(endWord)) return 0
  wordMap.delete(beginWord)

  const bfs = (bws: string[], ew: string, depth = 1): number => {
    if (!bws.length) return 0
    let newWords: string[] = []

    for (let bw of bws) {
      if (bw === ew) return depth

      for (let i = 0; i < bw.length; i++) {
        for (const char of 'abcdefghijklmnopqrstuvwxyz') {
          const newWord = bw.slice(0, i) + char + bw.slice(i + 1)
          if (!wordMap.has(newWord)) continue

          newWords.push(newWord)
          wordMap.delete(newWord)
        }
      }
    }
    return bfs(newWords, ew, depth + 1)
  }

  return bfs([beginWord], endWord)
}
```

## 解法 2: 双向 BFS

BFS 随着层数的增加,需要遍历的列表会呈指数级的增长,而如果从头尾开始查找,则能使单向递归的深度减半,从而极大的提升搜索效率.

在解法 1 的基础上,添加了从目标单词开始搜索的参数,因为两边的搜索逻辑都是一致的,所以每次只要将两边的参数对调一下,就能复用同一个逻辑.

```ts
function ladderLength(
  beginWord: string,
  endWord: string,
  wordList: string[],
): number {
  const beginWordSet = new Set(wordList)
  if (!beginWordSet.has(endWord)) return 0
  beginWordSet.delete(beginWord)
  const endWordSet = new Set(beginWordSet)
  endWordSet.delete(endWord)

  const bfs = (
    beginWords: Set<string>,
    beginWordList: Set<string>,
    endWords: Set<string>,
    endWordList: Set<string>,
    depth = 1,
  ): number => {
    if (!beginWords.size) return 0
    let tmpBeginWords = new Set<string>()

    for (let word of beginWords) {
      if (endWords.has(word)) return depth

      for (let i = 0; i < word.length; i++) {
        for (const char of 'abcdefghijklmnopqrstuvwxyz') {
          const newWord = word.slice(0, i) + char + word.slice(i + 1)
          if (!beginWordList.has(newWord)) continue

          tmpBeginWords.add(newWord)
          beginWordList.delete(newWord)
        }
      }
    }

    return bfs(endWords, endWordList, tmpBeginWords, beginWordList, depth + 1)
  }

  return bfs(new Set([beginWord]), beginWordSet, new Set([endWord]), endWordSet)
}
```
