# 20.有效的括号

```ts
/*
 * @lc app=leetcode.cn id=20 lang=typescript
 *
 * [20] 有效的括号
 */

// @lc code=start
function isValid(s: string): boolean {}
// @lc code=end
```

## 解法 1: 用栈(Stack)

- 时间复杂度: $O(n)$
- 空间复杂度: $O(n)$

```ts
function isValid(s: string): boolean {
  if (s.length % 2 !== 0) return false

  let minStack = []
  const closeMap: { [key: string]: string } = {
    ')': '(',
    ']': '[',
    '}': '{',
  }
  for (const c of s) {
    if (!(c in closeMap)) {
      minStack.push(c)
    } else {
      if (minStack.pop() !== closeMap[c]) {
        return false
      }
    }
  }
  return minStack.length === 0
}
```

```ts
function isValid(s: string): boolean {
  if (s.length % 2 !== 0) return false

  let minStack = []
  for (const c of s) {
    if (c === '(') {
      minStack.push(')')
    } else if (c === '[') {
      minStack.push(']')
    } else if (c === '{') {
      minStack.push('}')
    } else {
      if (minStack.pop() !== c) {
        return false
      }
    }
  }
  return minStack.length === 0
}
```

## 解法 2: 替换法

- 时间复杂度: $O(n^2)$
- 空间复杂度: $O(1)$

```ts
function isValid(s: string): boolean {
  if (s.length % 2 !== 0) return false

  let length = 0
  let regex = /(\(\))|(\[\])|(\{\})/g
  while (s.length !== length) {
    length = s.length
    s = s.replace(regex, '')
  }
  if (s.length === 0) {
    return true
  } else {
    return false
  }
}
```

## Case

```text
""()"\n
"()[]{}"\n
"(]"\n
"([)]"\n
"{[]}""
```
