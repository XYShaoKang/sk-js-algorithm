# 47.全排列-ii

```ts
/*
 * @lc app=leetcode.cn id=47 lang=typescript
 *
 * [47] 全排列 II
 */

// @lc code=start
function permuteUnique(nums: number[]): number[][] {}
// @lc code=end
```

## 解法 1: 回溯法

深度优先遍历,使用 cache 来保证每个元素都被访问并仅被访问一次,使用 tmp 来保证生成的同一个路径中的同一个位置不会有重复的元素出现.

```ts
function permuteUnique(nums: number[]): number[][] {
  let result: number[][] = []
  let cache: number[] = []
  let noRepeatNum = new Set(nums)

  for (const num of nums) {
    cache[num] ? cache[num]++ : (cache[num] = 1)
  }

  const backtrack = (nums: number[], path: number[] = []) => {
    if (nums.length === path.length) {
      result.push([...path])
      return
    }

    for (const num of noRepeatNum) {
      if (cache[num]) {
        cache[num]--
        path.push(num)

        backtrack(nums, path)

        path.pop()
        cache[num]++
      }
    }
  }
  backtrack(nums)

  return result
}
```

## 解法 2: 递归

```ts
function permuteUnique(nums: number[]): number[][] {
  const dfs = (
    nums: number[],
    start: number = 0,
    res: number[][] = [],
  ): number[][] => {
    if (start === nums.length) {
      res.push(nums)
      return res
    }
    for (let i = start; i < nums.length; i++) {
      if (i !== start && nums[i] === nums[start]) continue
      ;[nums[i], nums[start]] = [nums[start], nums[i]]
      dfs([...nums], start + 1, res)
    }
    return res
  }

  return dfs(nums.sort((a, b) => a - b))
}
```

## Case

```text
[3,3,0,3]\n
[2,2,1,1]
```
