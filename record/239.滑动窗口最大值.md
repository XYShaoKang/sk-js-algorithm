# 239.滑动窗口最大值

```ts
/*
 * @lc app=leetcode.cn id=239 lang=typescript
 *
 * [239] 滑动窗口最大值
 */

// @lc code=start
function maxSlidingWindow(nums: number[], k: number): number[] {}
// @lc code=end
```

## 解法 1: 暴力破解

- 时间复杂度: $O(n*k)$
- 空间复杂度: $O(k)$

```ts
function maxSlidingWindow(nums: number[], k: number): number[] {
  let slideWindow = []
  let maxArr = []
  for (let i = 0; i < nums.length; i++) {
    const element = nums[i]
    slideWindow.push(element)
    if (i >= k) {
      slideWindow.shift()
    }

    if (i > k - 2) {
      let max = -Infinity
      for (const item of slideWindow) {
        max = Math.max(item, max)
      }
      maxArr.push(max)
    }
  }
  return maxArr
}
```

## 解法 2: 使用双端队列

- 时间复杂度: $O(n+k)$
- 空间复杂度: $O(k)$

```ts
interface Node {
  index: number
  next: Node | null
  pre: Node | null
}

class Deque {
  start: Node | null = null
  end: Node | null = null
  addLast(n: number) {
    if (this.end === null) {
      this.start = this.end = { index: n, next: null, pre: null }
      // this.end = { value: n, next: null, pre: this.start }
    } else {
      const newNode = { index: n, next: null, pre: this.end }
      this.end.next = newNode
      this.end = newNode
    }
  }
  removeLast() {
    if (this.end && this.end.pre) {
      this.end = this.end.pre
      this.end.next = null
    } else {
      this.start = this.end = null
    }
  }
  getLast() {
    return this.end
  }
  addFirst(n: number) {
    if (this.start === null) {
      this.start = this.end = { index: n, next: null, pre: null }
    } else {
      const newNode = { index: n, next: this.start, pre: null }
      this.start.pre = newNode
      this.start = newNode
    }
  }
  removeFirst() {
    if (this.start && this.start.next) {
      this.start = this.start.next
      this.start.pre = null
    } else {
      this.start = this.end = null
    }
  }
  getFirst() {
    return this.start
  }
  isEmpty() {
    if (this.start === null) {
      return true
    }
    return false
  }
}
function maxSlidingWindow(nums: number[], k: number): number[] {
  let slideWindow = new Deque()
  let maxArr = []
  for (let i = 0; i < nums.length; i++) {
    while (
      !slideWindow.isEmpty() &&
      nums[slideWindow.getLast()!.index] < nums[i]
    ) {
      slideWindow.removeLast()
    }

    slideWindow.addLast(i)

    while (!slideWindow.isEmpty() && slideWindow.getFirst()!.index <= i - k) {
      slideWindow.removeFirst()
    }

    if (i >= k - 1) {
      maxArr.push(nums[slideWindow.getFirst()!.index])
    }
  }
  return maxArr
}
```

## 解法 3: 使用数组

- 时间复杂度: $O(n+k)$
- 空间复杂度: $O(k)$

> 官方题解中的答案,只是直接使用 shift 不会增加时间复杂度么?

```ts
function maxSlidingWindow(nums: number[], k: number): number[] {
  let slideWindow: Array<number> = []
  let maxArr = []
  for (let i = 0; i < nums.length; i++) {
    while (
      slideWindow.length &&
      nums[slideWindow[slideWindow.length - 1]] < nums[i]
    ) {
      slideWindow.pop()
    }

    slideWindow.push(i)

    if (slideWindow[0] <= i - k) {
      slideWindow.shift()
    }

    if (i >= k - 1) {
      maxArr.push(nums[slideWindow[0]])
    }
  }
  return maxArr
}
```

## 解法 4: 两次遍历

https://leetcode.com/problems/sliding-window-maximum/discuss/65881/O(n)-solution-in-Java-with-two-simple-pass-in-the-array

## Case

```text
[1,3,-1,-3,5,3,6,7]\n3\n
[5,3,4]\n1\n
[1,-1]\n1
```
