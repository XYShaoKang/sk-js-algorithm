# 84.柱状图中最大的矩形

```ts
/*
 * @lc app=leetcode.cn id=84 lang=typescript
 *
 * [84] 柱状图中最大的矩形
 */

// @lc code=start
function largestRectangleArea(heights: number[]): number {}
// @lc code=end
```

## 解法 1: 暴力枚举

时间复杂度: `O(n^2)`
空间复杂度: `O(1)`

```ts
function largestRectangleArea(heights: number[]): number {
  let maxArea = 0
  for (let i = 0; i < heights.length; i++) {
    let min = heights[i]
    for (let j = i; j < heights.length; j++) {
      min = Math.min(min, heights[j])
      maxArea = Math.max(maxArea, min * (j - i + 1))
    }
  }
  return maxArea
}
```

## 解法 2: 暴力枚举优化

时间复杂度: `O(n^2)`
空间复杂度: `O(1)`

```ts
function largestRectangleArea(heights: number[]): number {
  let maxArea = 0
  for (let i = 0; i < heights.length; i++) {
    let left = i
    let right = i + 1
    while (right < heights.length && heights[i] <= heights[right]) {
      right++
    }
    while (left >= 0 && heights[i] <= heights[left]) {
      left--
    }

    maxArea = Math.max(maxArea, heights[i] * (right - left - 1))
  }
  return maxArea
}
```

## 解法 3 使用最小栈

时间复杂度: `O(n)`
空间复杂度: `O(n)`

```ts
function largestRectangleArea(heights: number[]): number {
  let stack: Array<{ height: number; index: number }> = [
    { height: 0, index: -1 },
  ]
  let maxArea = 0
  for (let i = 0; i < heights.length; i++) {
    const right = heights[i]
    let left = stack[stack.length - 1]
    while (left && left.height > right) {
      let cur = stack.pop()!
      left = stack[stack.length - 1]

      maxArea = Math.max(maxArea, cur.height * (i - left.index - 1))
    }
    stack.push({ height: right, index: i })
  }

  let right = stack[stack.length - 1]

  while (stack.length > 1) {
    let cur = stack.pop()!
    let left = stack[stack.length - 1]
    maxArea = Math.max(maxArea, cur.height * (right.index - left.index))
  }
  return maxArea
}
```

## 解法 4 使用最小栈优化

时间复杂度: `O(n)`
空间复杂度: `O(n)`

```ts
function largestRectangleArea(heights: number[]): number {
  // 添加一个右边界 0,这样可以省掉后面的循环的代码,看起来精简很多
  // @ref: https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1430546/Monotonique-Stack-Solution-Intuition-(Javascript)
  heights.push(0)
  let stack: Array<{ height: number; index: number }> = [
    { height: 0, index: -1 },
  ]
  let maxArea = 0
  for (let i = 0; i < heights.length; i++) {
    const right = heights[i]
    let left = stack[stack.length - 1]
    while (left && left.height > right) {
      let cur = stack.pop()!
      left = stack[stack.length - 1]

      maxArea = Math.max(maxArea, cur.height * (i - left.index - 1))
    }
    stack.push({ height: right, index: i })
  }

  return maxArea
}
```

## Case

```text
[2,1,5,6,2,3]\n
[1]\n
[2,4]\n
[1,1]\n
[2,3]
```
