# 641.设计循环双端队列

```ts
/*
 * @lc app=leetcode.cn id=641 lang=typescript
 *
 * [641] 设计循环双端队列
 */

// @lc code=start
class MyCircularDeque {
  constructor(k: number) {}

  insertFront(value: number): boolean {}

  insertLast(value: number): boolean {}

  deleteFront(): boolean {}

  deleteLast(): boolean {}

  getFront(): number {}

  getRear(): number {}

  isEmpty(): boolean {}

  isFull(): boolean {}
}

/**
 * Your MyCircularDeque object will be instantiated and called as such:
 * var obj = new MyCircularDeque(k)
 * var param_1 = obj.insertFront(value)
 * var param_2 = obj.insertLast(value)
 * var param_3 = obj.deleteFront()
 * var param_4 = obj.deleteLast()
 * var param_5 = obj.getFront()
 * var param_6 = obj.getRear()
 * var param_7 = obj.isEmpty()
 * var param_8 = obj.isFull()
 */
// @lc code=end
```

## 解法 1: 使用数组实现

> 不太确定 shift 和 unshift 的时间复杂度,感觉复杂度应该是 O(n),但结果击败了 100% 的人,是测试用例太小了?

```ts
class MyCircularDeque {
  _siez: number
  _queue: number[]
  constructor(k: number) {
    this._siez = k
    this._queue = []
  }

  insertFront(value: number): boolean {
    if (this.isFull()) return false

    this._queue.unshift(value)
    return true
  }

  insertLast(value: number): boolean {
    if (this.isFull()) return false

    this._queue.push(value)
    return true
  }

  deleteFront(): boolean {
    if (this.isEmpty()) return false

    this._queue.shift()
    return true
  }

  deleteLast(): boolean {
    if (this.isEmpty()) return false

    this._queue.pop()
    return true
  }

  getFront(): number {
    return this.isEmpty() ? -1 : this._queue[0]
  }

  getRear(): number {
    return this.isEmpty() ? -1 : this._queue[this._queue.length - 1]
  }

  isEmpty(): boolean {
    return this._queue.length === 0
  }

  isFull(): boolean {
    return this._queue.length === this._siez
  }
}
```

## 解法 2: 符合题意 - 循环

- 时间复杂度:
  - insertFront: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - insertLast: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - deleteFront: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - deleteLast: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - getFront: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - getRear: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - isEmpty: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - isFull: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
- 空间复杂度: <!-- $O(n)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-n.svg" alt="O(n)">

```ts
class MyCircularDeque {
  deque: Array<number | null>
  front: number = 0
  rear: number = 1
  length: number
  constructor(k: number) {
    this.length = k + 1
    this.deque = new Array(this.length).fill(0)
  }
  _next(index: number) {
    return (index + 1) % this.length
  }
  _pre(index: number) {
    return (index - 1 + this.length) % this.length
  }

  insertFront(value: number): boolean {
    if (this.isFull()) return false

    this.deque[this.front] = value
    this.front = this._pre(this.front)
    return true
  }

  insertLast(value: number): boolean {
    if (this.isFull()) return false

    this.deque[this.rear] = value
    this.rear = this._next(this.rear)

    return true
  }

  deleteFront(): boolean {
    if (this.isEmpty()) return false

    this.front = this._next(this.front)
    return true
  }

  deleteLast(): boolean {
    if (this.isEmpty()) return false

    this.rear = this._pre(this.rear)
    return true
  }

  getFront(): number {
    return this.isEmpty() ? -1 : this.deque[this._next(this.front)]!
  }

  getRear(): number {
    return this.isEmpty() ? -1 : this.deque[this._pre(this.rear)]!
  }

  isEmpty(): boolean {
    return this.front === this._pre(this.rear)
  }

  isFull(): boolean {
    return this.front === this.rear
  }
}
```

## Case

```text
["MyCircularDeque","insertLast","insertLast","insertFront","insertFront","getRear","isFull","deleteLast","insertFront","getFront"]\n[[3],[1],[2],[3],[4],[],[],[],[4],[]]\n
["MyCircularDeque","insertFront","getFront","isEmpty","deleteFront","insertLast","getRear","insertLast","insertFront","deleteLast","insertLast","isEmpty"]\n[[8],[5],[],[],[],[3],[],[7],[7],[],[4],[]]\n
["MyCircularDeque","insertFront","insertLast","getFront","insertLast","getFront","insertFront","getRear","getFront","getFront","deleteLast","getRear"]\n[[5],[7],[0],[],[3],[],[9],[],[],[],[],[]]\n
["MyCircularDeque","insertFront","insertLast","getFront","insertLast","getRear","getFront","insertLast","insertLast","insertLast","deleteLast","getFront"]\n[[7],[1],[0],[],[8],[],[],[2],[0],[4],[],[]]\n
["MyCircularDeque","insertFront","deleteLast","getRear","getFront","getFront","deleteFront","insertFront","insertLast","insertFront","getFront","insertFront"]\n[[4],[9],[],[],[],[],[],[6],[5],[9],[],[6]]\n
["MyCircularDeque","insertFront","deleteLast","getFront","insertLast","insertFront","getFront","getRear","getFront","getFront","getRear","insertLast"]\n[[2],[7],[],[],[5],[0],[],[],[],[],[],[0]]
```
