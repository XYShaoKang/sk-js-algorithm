# 641.设计循环双端队列

```ts
/*
 * @lc app=leetcode.cn id=641 lang=typescript
 *
 * [641] 设计循环双端队列
 */

// @lc code=start
class MyCircularDeque {
  constructor(k: number) {}

  insertFront(value: number): boolean {}

  insertLast(value: number): boolean {}

  deleteFront(): boolean {}

  deleteLast(): boolean {}

  getFront(): number {}

  getRear(): number {}

  isEmpty(): boolean {}

  isFull(): boolean {}
}

/**
 * Your MyCircularDeque object will be instantiated and called as such:
 * var obj = new MyCircularDeque(k)
 * var param_1 = obj.insertFront(value)
 * var param_2 = obj.insertLast(value)
 * var param_3 = obj.deleteFront()
 * var param_4 = obj.deleteLast()
 * var param_5 = obj.getFront()
 * var param_6 = obj.getRear()
 * var param_7 = obj.isEmpty()
 * var param_8 = obj.isFull()
 */
// @lc code=end
```

## 解法 1: 使用双向链表实现

- 时间复杂度:
  - insertFront: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - insertLast: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - deleteFront: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - deleteLast: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - getFront: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - getRear: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - isEmpty: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - isFull: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
- 空间复杂度: <!-- $O(n)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-n.svg" alt="O(n)">

```ts
interface Node {
  index: number
  next: Node | null
  pre: Node | null
  value: number
}
class MyCircularDeque {
  front: Node | null = null
  rear: Node | null = null
  length: number
  constructor(k: number) {
    this.length = k
  }

  insertFront(value: number): boolean {
    if (this.isFull()) {
      return false
    }
    if (this.front === null) {
      this.front = this.rear = { value, index: 0, next: null, pre: null }
    } else {
      const newNode = {
        value,
        index: this.front.index - 1,
        next: this.front,
        pre: null,
      }
      this.front.pre = newNode
      this.front = newNode
    }
    return true
  }

  insertLast(value: number): boolean {
    if (this.isFull()) {
      return false
    }
    if (this.rear === null) {
      this.front = this.rear = { value, index: 0, next: null, pre: null }
    } else {
      const newNode = {
        value,
        index: this.rear.index + 1,
        next: null,
        pre: this.rear,
      }
      this.rear.next = newNode
      this.rear = newNode
    }
    return true
  }

  deleteFront(): boolean {
    if (this.isEmpty()) {
      return false
    }
    if (this.front && this.front.next) {
      this.front = this.front.next
      this.front.pre = null
    } else {
      this.front = this.rear = null
    }
    return true
  }

  deleteLast(): boolean {
    if (this.isEmpty()) {
      return false
    }
    if (this.rear && this.rear.pre) {
      this.rear = this.rear.pre
      this.rear.next = null
    } else {
      this.front = this.rear = null
    }
    return true
  }

  getFront(): number {
    return this.front?.value ?? -1
  }

  getRear(): number {
    return this.rear?.value ?? -1
  }

  isEmpty(): boolean {
    return this.front === null
  }

  isFull(): boolean {
    if (
      this.isEmpty() ||
      this.rear!.index - this.front!.index < this.length - 1
    ) {
      return false
    }
    return true
  }
}
```

## 解法 2: 使用数组实现

- 时间复杂度:
  - insertFront: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - insertLast: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - deleteFront: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - deleteLast: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - getFront: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - getRear: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - isEmpty: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - isFull: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
- 空间复杂度: <!-- $O(n)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-n.svg" alt="O(n)">

> 不太确定 shift 和 unshift 的时间复杂度,感觉复杂度应该是 O(n),但结果跟解法 1 一样击败了 100% 的人,是测试用例太小了?

```ts
class MyCircularDeque {
  deque: Array<number> = []
  length: number
  constructor(k: number) {
    this.length = k
  }

  insertFront(value: number): boolean {
    if (this.isFull()) {
      return false
    }
    this.deque.unshift(value)
    return true
  }

  insertLast(value: number): boolean {
    if (this.isFull()) {
      return false
    }
    this.deque.push(value)
    return true
  }

  deleteFront(): boolean {
    if (this.isEmpty()) {
      return false
    }
    this.deque.shift()
    return true
  }

  deleteLast(): boolean {
    if (this.isEmpty()) {
      return false
    }
    this.deque.pop()
    return true
  }

  getFront(): number {
    return this.deque[0] ?? -1
  }

  getRear(): number {
    return this.deque[this.deque.length - 1] ?? -1
  }

  isEmpty(): boolean {
    return this.deque.length === 0
  }

  isFull(): boolean {
    if (this.deque.length < this.length) {
      return false
    }
    return true
  }
}
```

## 解法 3: 符合题意 - 循环

- 时间复杂度:
  - insertFront: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - insertLast: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - deleteFront: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - deleteLast: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - getFront: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - getRear: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - isEmpty: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
  - isFull: <!-- $O(1)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-1.svg" alt="O(1)">
- 空间复杂度: <!-- $O(n)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-n.svg" alt="O(n)">

```ts
class MyCircularDeque {
  deque: Array<number | null>
  front: number = 0
  rear: number = 1
  length: number
  constructor(k: number) {
    this.length = k + 1
    this.deque = new Array(this.length).fill(0)
  }
  _next(index: number) {
    return (index + 1) % this.length
  }
  _pre(index: number) {
    return (index - 1 + this.length) % this.length
  }

  insertFront(value: number): boolean {
    if (this.isFull()) {
      return false
    }

    this.deque[this.front] = value
    this.front = this._pre(this.front)
    return true
  }

  insertLast(value: number): boolean {
    if (this.isFull()) {
      return false
    }
    this.deque[this.rear] = value
    this.rear = this._next(this.rear)

    return true
  }

  deleteFront(): boolean {
    if (this.isEmpty()) {
      return false
    }
    this.front = this._next(this.front)
    return true
  }

  deleteLast(): boolean {
    if (this.isEmpty()) {
      return false
    }
    this.rear = this._pre(this.rear)
    return true
  }

  getFront(): number {
    return this.isEmpty() ? -1 : this.deque[this._next(this.front)]!
  }

  getRear(): number {
    return this.isEmpty() ? -1 : this.deque[this._pre(this.rear)]!
  }

  isEmpty(): boolean {
    return this.front === this._pre(this.rear)
  }

  isFull(): boolean {
    return this.front === this.rear
  }
}
```

## Case

```text
["MyCircularDeque","insertLast","insertLast","insertFront","insertFront","getRear","isFull","deleteLast","insertFront","getFront"]\n[[3],[1],[2],[3],[4],[],[],[],[4],[]]\n
["MyCircularDeque","insertFront","getFront","isEmpty","deleteFront","insertLast","getRear","insertLast","insertFront","deleteLast","insertLast","isEmpty"]\n[[8],[5],[],[],[],[3],[],[7],[7],[],[4],[]]\n
["MyCircularDeque","insertFront","insertLast","getFront","insertLast","getFront","insertFront","getRear","getFront","getFront","deleteLast","getRear"]\n[[5],[7],[0],[],[3],[],[9],[],[],[],[],[]]\n
["MyCircularDeque","insertFront","insertLast","getFront","insertLast","getRear","getFront","insertLast","insertLast","insertLast","deleteLast","getFront"]\n[[7],[1],[0],[],[8],[],[],[2],[0],[4],[],[]]\n
["MyCircularDeque","insertFront","deleteLast","getRear","getFront","getFront","deleteFront","insertFront","insertLast","insertFront","getFront","insertFront"]\n[[4],[9],[],[],[],[],[],[6],[5],[9],[],[6]]\n
["MyCircularDeque","insertFront","deleteLast","getFront","insertLast","insertFront","getFront","getRear","getFront","getFront","getRear","insertLast"]\n[[2],[7],[],[],[5],[0],[],[],[],[],[],[0]]
```
