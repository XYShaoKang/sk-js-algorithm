# 433.最小基因变化

```ts
/*
 * @lc app=leetcode.cn id=433 lang=typescript
 *
 * [433] 最小基因变化
 */

// @lc code=start
function minMutation(start: string, end: string, bank: string[]): number {}
// @lc code=end
```

## 解法 1: 递归 1

根据题意,每次只能变化一个字符,那去检查合法库中是否有跟当前字符串相差一个字符的字符串,如果有就变成变成变成拿个字符串,并从合法库中去掉,在继续判断,直到最终变成 end(这是取得变化次数),或者合法库已经变完了(说明没有变化成功),然后去比对那些成功变化的次数,取最小值

```ts
function minMutation(start: string, end: string, bank: string[]): number {
  let minDif = Infinity
  function difone(str1: string, str2: string) {
    let difLength = 0
    for (let i = 0; i < str1.length; i++) {
      if (str1[i] !== str2[i]) {
        difLength++
      }
    }
    return difLength === 1
  }
  const recursive = (start: string, end: string, bank: string[], dif = 0) => {
    if (start === end) {
      minDif = Math.min(minDif, dif)
      return
    }
    if (!bank.length || start === end) return

    for (let index = 0; index < bank.length; index++) {
      const element = bank[index]
      if (difone(element, start)) {
        recursive(
          element,
          end,
          bank.filter((_, i) => i !== index),
          dif + 1,
        )
      }
    }
  }
  recursive(start, end, bank)
  return minDif === Infinity ? -1 : minDif
}
```

## 解法 2: 递归 2

```ts
function minMutation(start: string, end: string, bank: string[]): number {
  const map = 'ACGT'.split('')
  let minMtation = Infinity
  bank.push(start)
  const recursive = (
    start: string,
    end: string,
    bank: string[],
    mtation = 0,
  ) => {
    // console.log(start, end, bank, mtation)
    if (start === end) {
      minMtation = Math.min(minMtation, mtation)
      return
    }

    for (let i = 0; i < start.length; i++) {
      // if (start[i] === end[i]) continue
      for (const c of map) {
        if (c === start[i]) continue
        const newStr = start.slice(0, i) + c + start.slice(i + 1, start.length)
        if (!bank.includes(newStr)) continue

        recursive(
          newStr,
          end,
          bank.filter((s) => s !== newStr),
          mtation + 1,
        )
      }
    }
  }
  recursive(start, end, bank)
  return minMtation === Infinity ? -1 : minMtation
}
```
