# 22.括号生成

```ts
/*
 * @lc app=leetcode.cn id=22 lang=typescript
 *
 * [22] 括号生成
 */

// @lc code=start
function generateParenthesis(n: number): string[] {}
// @lc code=end
```

## 解法 1: 递归

### 思路

使用一对括号`()`,而不是把左括号`(`右括号`)`分开来操作.这样就直接过滤掉那些无效的组合.

然后将这一对括号插入到下一层递归生成的字符串中的每个缝隙之中,就能生成这一层的所有组合.

当然这样会有很多重复的数据,所以使用 Set 去重.

![生成括号](../assets/generate-parentheses.png)

### 实现

时间复杂度: `O(2^n)`
空间复杂度: `O(n)`

因为直接生成有效组合,加上去重,并且使用的层数只用 n 而不用 2n,整体的时间复杂度会比回溯法来的快,大于 2^n 小于 3^n

> 没有计算 slice 的时间复杂度,不过 V8 中有针对 slice 优化,可以默认为 O(1),其他引擎待考察
> https://stackoverflow.com/a/47733726

```ts
function generateParenthesis(n: number): string[] {
  const helper = (n: number): Set<string> => {
    if (n < 2) {
      return new Set(['()'])
    }

    const strs = helper(n - 1)
    const result = new Set<string>()
    for (const str of strs) {
      for (let j = 0; j < str.length; j++) {
        let tmp = str.slice(0, j) + '()' + str.slice(j, str.length)
        if (!result.has(tmp)) {
          result.add(tmp)
        }
      }
    }
    return result
  }

  return [...helper(n)]
}
```

## 解法 2: 递归 2

时间复杂度: `O(n^2)`
空间复杂度: `O(n)`

```ts
function generateParenthesis(n: number): string[] {
  const helper = (
    left: number,
    right: number,
    str: string,
    parenthesis: Array<string>,
  ) => {
    if (!right) {
      parenthesis.push(str)
      return
    }

    if (left) helper(left - 1, right, str + '(', parenthesis)
    if (right > left) helper(left, right - 1, str + ')', parenthesis)
    return
  }
  const parenthesis: Array<string> = []
  helper(n, n, '', parenthesis)
  return parenthesis
}
```
