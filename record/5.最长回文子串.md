# 5.最长回文子串

```ts
/*
 * @lc app=leetcode.cn id=5 lang=typescript
 *
 * [5] 最长回文子串
 */

// @lc code=start
function longestPalindrome(s: string): string {}
// @lc code=end
```

## 解法 1: 动态规划

- 时间复杂度: <!-- $O(n^2)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-n-^-2.svg" alt="O(n^2)">
- 空间复杂度: <!-- $O(n^2)$ --> <img style="transform: translateY(0.1em); background: white;" src="./svg/o-n-^-2.svg" alt="O(n^2)">

- 动态规划
- 状态: `dp[i][j]` 以第 i 个字符结尾的回文子串长度
- 递推公式:
  - `s[i]===s[i-dp[i-1][j]-1]: dp[i][j] = dp[i-1][j]+2`
- 边界: `dp[i]=[0,1]`

> 看很多题解中,不管是动态规划(`dp[i][j]`表示子串`s[i..j]`是否为子串),还是中心扩散,第二层的遍历需要一个一个字符的去遍历
>
> 而在这个动态规划中,`dp[i][j]`表示的是以`s[i]`结尾的回文子串的集合,在大多数情况下,这个集合的数量肯定会小于一个个字符去遍历的长度,而`dp[i]`只需要从`dp[i-1]`中转移,不必要一个个字符去遍历,这样会快很多
>
> 当然,如果是一些比较极端的例子,比如像`aaaaaaa`这样的情况,复杂度还是会到 O(n^2)

```ts
function longestPalindrome(s: string): string {
  const dp = new Array(s.length).fill(0).map(() => [0, 1])
  let [start, end] = [0, 1]
  for (let i = 1; i < s.length; i++) {
    for (const l of dp[i - 1]) {
      if (s[i] === s[i - l - 1]) dp[i].push(l + 2)
    }
    const len = dp[i][dp[i].length - 1]
    if (len > end - start) [start, end] = [i - len + 1, i + 1]
  }
  return s.slice(start, end)
}
```

## Case

```ts
test.each([
  { input: { s: 'babad' }, output: 'bab' },
  { input: { s: 'cbbd' }, output: 'bb' },
  { input: { s: 'a' }, output: 'a' },
  { input: { s: 'ac' }, output: 'a' },
])('input: s = $input.s', ({ input: { s }, output }) => {
  expect(longestPalindrome(s)).toEqual(output)
})
```
